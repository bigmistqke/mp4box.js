import { Log } from 'mp4box';
export class Downloader {
  chunkSize = 0;
  chunkStart = 0;
  chunkTimeout = 1000;
  eof = false;
  isActive = false;
  realtime = false;
  timeoutID: number | null = null;
  totalLength = 0;
  url: string | null = null;

  #callback: ((response: any, end: boolean, error?: any) => void) | null = null;
  #downloadTimeoutCallback: ((duration: number) => void) | null = null;

  setDownloadTimeoutCallback(callback: () => void) {
    this.#downloadTimeoutCallback = callback;
    return this;
  }

  reset() {
    this.chunkStart = 0;
    this.totalLength = 0;
    this.eof = false;
    return this;
  }

  setRealTime(_realtime: boolean) {
    this.realtime = _realtime;
    return this;
  }

  setChunkSize(_size: number) {
    this.chunkSize = _size;
    return this;
  }

  setChunkStart(_start: number) {
    this.chunkStart = _start;
    this.eof = false;
    return this;
  }

  setInterval(_timeout: number) {
    this.chunkTimeout = _timeout;
    return this;
  }

  setUrl(_url: string | null) {
    this.url = _url;
    return this;
  }

  setCallback(_callback: ((response: any, end: any, error: any) => void) | null) {
    this.#callback = _callback;
    return this;
  }

  isStopped() {
    return !this.isActive;
  }

  getFileLength() {
    return this.totalLength;
  }

  getFile() {
    if (this.totalLength && this.chunkStart >= this.totalLength) {
      this.eof = true;
    }
    if (this.eof === true) {
      Log.info('Downloader', 'File download done.');
      this.#callback?.(null, true);
      return;
    }
    if (!this.url) {
      Log.error('Downloader', 'Tried getting file without url defined');
      return;
    }
    var xhr = new XMLHttpRequest() as XMLHttpRequest & { start: number };
    xhr.open('GET', this.url, true);
    xhr.responseType = 'arraybuffer';
    var range = null;
    xhr.start = this.chunkStart;
    var maxRange;
    if (this.chunkStart + this.chunkSize < Infinity) {
      range = 'bytes=' + this.chunkStart + '-';
      maxRange = this.chunkStart + this.chunkSize - 1;
      /* if the file length is known we limit the max range to that length */
      /*if (dl.totalLength !== 0) {
        maxRange = Math.min(maxRange, dl.totalLength);
      }*/
      range += maxRange;
      xhr.setRequestHeader('Range', range);
    }
    xhr.onerror = e => {
      this.#callback?.(null, false, true);
    };
    xhr.onreadystatechange = e => {
      if (xhr.status == 404) {
        this.#callback?.(null, false, true);
      }
      if (
        (xhr.status == 200 || xhr.status == 206 || xhr.status == 304 || xhr.status == 416) &&
        xhr.readyState == this.DONE
      ) {
        var rangeReceived = xhr.getResponseHeader('Content-Range');
        Log.info('Downloader', 'Received data range: ' + rangeReceived);
        /* if the length of the file is not known, we get it from the response header */
        if (!this.totalLength && rangeReceived) {
          var sizeIndex;
          sizeIndex = rangeReceived.indexOf('/');
          if (sizeIndex > -1) {
            this.totalLength = +rangeReceived.slice(sizeIndex + 1);
          }
        }
        this.eof =
          xhr.response.byteLength !== this.chunkSize ||
          xhr.response.byteLength === this.totalLength;
        var buffer = xhr.response;
        buffer.fileStart = xhr.start;
        if (!buffer.fileStart) {
          // IE does not support adding properties to an ArrayBuffer generated by XHR
          buffer = buffer.slice(0);
          buffer.fileStart = xhr.start;
        }
        this.#callback?.(buffer, this.eof);
        if (this.isActive === true && this.eof === false) {
          var timeoutDuration = 0;
          if (!this.realtime) {
            timeoutDuration = this.chunkTimeout;
          } else {
            // timeoutDuration = computeWaitingTimeFromBuffer(video);
          }
          if (this.#downloadTimeoutCallback) this.#downloadTimeoutCallback(timeoutDuration);
          Log.info(
            'Downloader',
            'Next download scheduled in ' + Math.floor(timeoutDuration) + ' ms.',
          );
          this.timeoutID = window.setTimeout(this.getFile.bind(this), timeoutDuration);
        } else {
          /* end of file */
          this.isActive = false;
        }
      }
    };
    if (this.isActive) {
      Log.info('Downloader', 'Fetching ' + this.url + (range ? ' with range: ' + range : ''));
      xhr.send();
    }
  }

  start() {
    Log.info('Downloader', 'Starting file download');
    this.chunkStart = 0;
    this.resume();
    return this;
  }

  resume() {
    Log.info('Downloader', 'Resuming file download');
    this.isActive = true;
    if (this.chunkSize === 0) {
      this.chunkSize = Infinity;
    }
    this.getFile();
    return this;
  }

  stop() {
    Log.info('Downloader', 'Stopping file download');
    this.isActive = false;
    if (this.timeoutID) {
      window.clearTimeout(this.timeoutID);
      this.timeoutID = null;
    }
    return this;
  }
}
